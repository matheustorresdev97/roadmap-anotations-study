### Operações básicas da álgebra relacional
- Restrição
- Projeção
- Produto cartesiano
- Junção (produto cartesiano + restrição de chaves correspondentes)


![[Captura de tela de 2025-04-10 07-29-26.png]]

![[Captura de tela de 2025-04-10 07-30-26.png]]

![[Captura de tela de 2025-04-10 07-31-31.png]]


![[Captura de tela de 2025-04-10 07-32-44.png]]


### Revisão de OO  e SQL com Java e JDBC

- Criação e instanciação da base de dados

```sql
create table tb_order (
    id int8 generated by default as identity, 
    latitude float8, 
    longitude float8, 
    moment TIMESTAMP WITHOUT TIME ZONE, 
    status int4, 
    primary key (id)
);

create table tb_order_product (
    order_id int8 not null, 
    product_id int8 not null, 
    primary key (order_id, product_id)
);

create table tb_product (
    id int8 generated by default as identity, 
    description TEXT, 
    image_uri varchar(255), 
    name varchar(255), 
    price float8, 
    primary key (id)
);

alter table if exists tb_order_product add constraint fk_tb_order_product_tb_product 
foreign key (product_id) references tb_product;

alter table if exists tb_order_product add constraint fk_tb_order_product_tb_order 
foreign key (order_id) references tb_order;

INSERT INTO tb_product (name, price, image_Uri, description) VALUES 
('Pizza de Calabresa', 50.0, 'https://github.com/devsuperior/1.png', 'Pizza calabresa com queijo, molho e massa especial'),
('Pizza Quatro Queijos', 40.0, 'https://github.com/devsuperior/2.png', 'Pizza quatro queijos muito boa'),
('Pizza de Escarola', 60.0, 'https://github.com/devsuperior/3.png', 'Pizza escarola muito boa');

INSERT INTO tb_order (status, latitude, longitude, moment) VALUES 
(0, 213123, 12323, TIMESTAMP WITH TIME ZONE '2021-01-04T11:00:00Z'),
(1, 3453453, 3534534, TIMESTAMP WITH TIME ZONE '2021-01-05T11:00:00Z');

INSERT INTO tb_order_product (order_id, product_id) VALUES 
(1 , 1),
(1 , 2),
(2 , 2),
(2 , 3);
```

- Chave Primária (Primary Key)
Uma chave primária é um campo (ou combinação de campos) que identifica de forma única cada registro em uma tabela. Características importantes:
1. Não pode conter valores nulos
2. Deve ser única para cada registro
3. Cada tabela pode ter apenas uma chave primária

No exemplo:
Na tabela `tb_order`, a chave primária é o campo `id`:
```sql
primary key (id)
```

Na tabela `tb_product`, a chave primária também é o campo `id`:
```sql
primary key (id)
```

Na tabela `tb_order_product`, a chave primária é uma chave composta pelos campos `order_id` e `product_id`:
```sql
primary key (order_id, product_id)
```

- Chave Estrangeira (Foreign Key)
Uma chave estrangeira é um campo (ou conjunto de campos) em uma tabela que se refere à chave primária de outra tabela. Características importantes:
Estabelece relacionamentos entre tabelas
Garante a integridade referencial
Previne a inserção de dados inválidos

No exemplo:
Na tabela `tb_order_product`, existem duas chaves estrangeiras:

`product_id` referencia a chave primária da tabela `tb_product`:
```sql
add constraint fk_tb_order_product_tb_product foreign key (product_id) references tb_product
```

`order_id` referencia a chave primária da tabela `tb_order`:
```sql
add constraint fk_tb_order_product_tb_order foreign key (order_id) references tb_order
```

Neste exemplo, temos um modelo de pedidos e produtos:
`tb_order`: Armazena informações sobre pedidos (localização, momento, status)
`tb_product`: Armazena informações sobre produtos (nome, descrição, preço, imagem)
`tb_order_product`: É uma tabela de associação que implementa um relacionamento muitos-para-muitos entre pedidos e produtos
A tabela `tb_order_product` é necessária porque um pedido pode conter vários produtos, e um produto pode estar em vários pedidos. Sua chave primária composta e suas chaves estrangeiras garantem que cada combinação de pedido e produto seja única e válida.

- DDL (Data Definition Language)
DDL é a parte da linguagem SQL usada para definir e gerenciar estruturas de dados em um banco de dados. No seu exemplo, você utilizou comandos DDL como `CREATE TABLE` e `ALTER TABLE`:

- CREATE TABLE

O comando `CREATE TABLE` é usado para criar novas tabelas no banco de dados. Ele define:

- Nome da tabela
- Colunas e seus tipos de dados
- Restrições (como chaves primárias)

```sql
create table tb_product (
    id int8 generated by default as identity, 
    description TEXT, 
    image_uri varchar(255), 
    name varchar(255), 
    price float8, 
    primary key (id)
);
```

Neste caso, você está criando uma tabela chamada `tb_product` com:
- Um identificador automático (`id`)
- Campos para descrição, URI da imagem, nome e preço
- Uma restrição de chave primária no campo `id`

- ALTER TABLE
O comando `ALTER TABLE` é usado para modificar uma tabela existente. No seu caso, usado para adicionar restrições de chave estrangeira:

```sql
alter table if exists tb_order_product add constraint fk_tb_order_product_tb_product 
foreign key (product_id) references tb_product;
```

Este comando adiciona uma restrição de chave estrangeira à tabela `tb_order_product`, vinculando o campo `product_id` à tabela `tb_product`.

DML (Data Manipulation Language)
Os comandos `INSERT INTO` que você mostrou são exemplos de DML (Linguagem de Manipulação de Dados), não DDL. Eles são usados para inserir dados nas tabelas:
```sql
INSERT INTO tb_product (name, price, image_Uri, description) VALUES 
('Pizza de Calabresa', 50.0, 'https://github.com/devsuperior/1.png', 'Pizza calabresa com queijo, molho e massa especial');
```

Este comando insere um novo registro na tabela `tb_product` com os valores especificados para nome, preço, URI da imagem e descrição.

No exemplo:

1. Você inseriu 3 produtos (pizzas) na tabela `tb_product`
2. Adicionou 2 pedidos na tabela `tb_order` com diferentes status
3. Criou 4 associações entre pedidos e produtos na tabela `tb_order_product`:
    - Pedido 1 contém os produtos 1 e 2
    - Pedido 2 contém os produtos 2 e 3

Ao trabalhar com JDBC em Java, você usaria a classe `Statement` ou `PreparedStatement` para executar esses comandos SQL no banco de dados.


- Mapeamento Objeto-Relacional  (ORM) 

```java
public class Product {

	private Long id;
	private String name;
	private Double price;
	private String description;
	private String imageUri;
	
	public Product() {
	}

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Double getPrice() {
		return price;
	}

	public void setPrice(Double price) {
		this.price = price;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public String getImageUri() {
		return imageUri;
	}

	public void setImageUri(String imageUri) {
		this.imageUri = imageUri;
	}

	@Override
	public String toString() {
		return "Product [id=" + id + ", name=" + name + ", price=" + price + ", description=" + description
				+ ", imageUri=" + imageUri + "]";
	}
```

```java
public class Order {

    private Long id;
    private Double latitude;
    private Double longitude;
    private Instant moment;
    private OrderStatus status;
    private List<Product> products = new ArrayList<>();

    public Order() {
    }

	public Long getId() {
		return id;
	}

	public void setId(Long id) {
		this.id = id;
	}

	public Double getLatitude() {
		return latitude;
	}

	public void setLatitude(Double latitude) {
		this.latitude = latitude;
	}

	public Double getLongitude() {
		return longitude;
	}

	public void setLongitude(Double longitude) {
		this.longitude = longitude;
	}

	public Instant getMoment() {
		return moment;
	}

	public void setMoment(Instant moment) {
		this.moment = moment;
	}

	public OrderStatus getStatus() {
		return status;
	}

	public void setStatus(OrderStatus status) {
		this.status = status;
	}

	public List<Product> getProducts() {
		return products;
	}
	
	public double getTotal() {
		double sum = 0.0;
		for (Product p : products) {
			sum += p.getPrice();
		}
		return sum;
	}

	@Override
	public String toString() {
		return "Order [id=" + id + ", latitude=" + latitude + ", longitude=" + longitude + ", moment=" + moment
				+ ", status=" + status + ", getTotal()=" + getTotal() + "]";
	}	
}
```

```java
public enum OrderStatus {

	PENDING, DELIVERED;
}
```

Classe `Product`

Esta classe representa a tabela `tb_product` e possui todos os campos correspondentes:

- `id` (Long) mapeia para `id` (int8)
- `name` (String) mapeia para `name` (varchar)
- `price` (Double) mapeia para `price` (float8)
- `description` (String) mapeia para `description` (TEXT)
- `imageUri` (String) mapeia para `image_uri` (varchar)

A classe inclui getters, setters e um método `toString()` para facilitar a depuração.

 Enum `OrderStatus`

Este enum representa o status de um pedido com dois possíveis valores:

- `PENDING` (0)
- `DELIVERED` (1)

Isso corresponde ao campo `status` (int4) na tabela `tb_order`.

 Classe `Order`

Esta classe representa a tabela `tb_order` e possui:

- `id` (Long) mapeia para `id` (int8)
- `latitude` (Double) mapeia para `latitude` (float8)
- `longitude` (Double) mapeia para `longitude` (float8)
- `moment` (Instant) mapeia para `moment` (TIMESTAMP)
- `status` (OrderStatus) mapeia para `status` (int4)

Além disso, a classe possui:

- Uma lista de produtos (`List<Product> products`) que representa o relacionamento muitos-para-muitos com a tabela `tb_product` através da tabela de junção `tb_order_product`
- Um método `getTotal()` que calcula o valor total do pedido somando os preços dos produtos
- Getters, setters e um método `toString()`

 Observações sobre o mapeamento

1. **Relacionamento muitos-para-muitos**: O relacionamento entre `Order` e `Product` é corretamente implementado através de uma lista em `Order`. A tabela de junção `tb_order_product` não é diretamente representada como uma classe, mas sim como uma relação entre as duas entidades.
2. **Tipo de dados temporal**: Você usou `java.time.Instant` para representar o campo `moment`, o que é uma boa prática para lidar com timestamps em Java moderno.
3. **Enum para status**: O uso de um enum para representar o status do pedido torna o código mais legível e type-safe, evitando o uso direto de inteiros.

 Coleções (list, map)

Você utilizou `ArrayList<Product>` para representar a relação de muitos-para-muitos entre pedidos e produtos. Coleções são fundamentais para gerenciar grupos de objetos relacionados.

 Acessar dados em BD relacional e instanciar objetos correspondentes

Embora não seja mostrado em seu código, este processo normalmente envolve:

1. Estabelecer conexão com o banco usando JDBC
2. Executar consultas SQL
3. Mapear resultados para objetos Java

```java
// Pseudocódigo para DAO
public Product findById(Long id) {
    Connection conn = /* obter conexão */;
    PreparedStatement stmt = conn.prepareStatement("SELECT * FROM tb_product WHERE id = ?");
    stmt.setLong(1, id);
    ResultSet rs = stmt.executeQuery();
    
    if (rs.next()) {
        Product product = new Product();
        product.setId(rs.getLong("id"));
        product.setName(rs.getString("name"));
        product.setPrice(rs.getDouble("price"));
        product.setDescription(rs.getString("description"));
        product.setImageUri(rs.getString("image_uri"));
        return product;
    }
    return null;
}
```

Para relacionamentos como Order-Product, você precisaria de consultas JOIN ou múltiplas consultas para montar a estrutura completa dos objetos.



```java
Vamos revisar esses conceitos fundamentais de Orientação a Objetos e JDBC no contexto do seu código:

## Classes e Objetos

Você implementou três entidades principais:

- `Product`: representa um produto (pizza) com seus atributos e comportamentos
- `Order`: representa um pedido com localização, momento e produtos associados
- `OrderStatus`: um tipo enumerado representando os possíveis status de um pedido

As classes `Product` e `Order` definem a estrutura dos objetos, enquanto instâncias dessas classes representam dados específicos (como uma pizza específica ou um pedido específico).

## Encapsulamento, get/set

Seu código implementa corretamente o encapsulamento:

- Atributos privados (`private Long id`, `private String name`, etc.)
- Métodos públicos para acessar e modificar esses atributos (getters e setters)

Isso protege os dados internos dos objetos, permitindo acesso controlado e validação quando necessário.

## Tipos Enumerados

Você criou o enum `OrderStatus` com valores `PENDING` e `DELIVERED`. Enums são perfeitos para representar conjuntos fixos de valores relacionados, tornando o código mais legível e seguro que usar constantes numéricas.

## Composição de Objetos

A classe `Order` demonstra composição ao conter:

- Tipos primitivos e wrappers (`Long`, `Double`)
- Tipos de referência (`Instant`)
- Um tipo enumerado (`OrderStatus`)
- Uma coleção de outros objetos (`List<Product>`)

Esta é uma relação "tem-um" - um pedido tem produtos, um status, etc.

## Coleções (list, map)

Você utilizou `ArrayList<Product>` para representar a relação de muitos-para-muitos entre pedidos e produtos. Coleções são fundamentais para gerenciar grupos de objetos relacionados.

Em seu código:

```java
private List<Product> products = new ArrayList<>();
```

Você segue uma boa prática ao declarar o tipo como a interface `List` e instanciar como a implementação `ArrayList`.

## Acessar dados em BD relacional e instanciar objetos correspondentes

Embora não seja mostrado em seu código, este processo normalmente envolve:

1. Estabelecer conexão com o banco usando JDBC
2. Executar consultas SQL
3. Mapear resultados para objetos Java

Por exemplo, para carregar um `Product`:

```java
// Pseudocódigo para DAO
public Product findById(Long id) {
    Connection conn = /* obter conexão */;
    PreparedStatement stmt = conn.prepareStatement("SELECT * FROM tb_product WHERE id = ?");
    stmt.setLong(1, id);
    ResultSet rs = stmt.executeQuery();
    
    if (rs.next()) {
        Product product = new Product();
        product.setId(rs.getLong("id"));
        product.setName(rs.getString("name"));
        product.setPrice(rs.getDouble("price"));
        product.setDescription(rs.getString("description"));
        product.setImageUri(rs.getString("image_uri"));
        return product;
    }
    return null;
}
```

Para relacionamentos como Order-Product, você precisaria de consultas JOIN ou múltiplas consultas para montar a estrutura completa dos objetos.
 

```java
	public static void main(String[] args) throws SQLException {
		
		Connection conn = DB.getConnection();
	
		Statement st = conn.createStatement();
			
		ResultSet rs = st.executeQuery("SELECT * FROM tb_order "
				+ "INNER JOIN tb_order_product ON tb_order.id = tb_order_product.order_id "
				+ "INNER JOIN tb_product ON tb_product.id = tb_order_product.product_id");
			
		Map<Long, Order> map = new HashMap<>();
		while (rs.next()) {
			Long orderId = rs.getLong("order_id");

			if (map.get(orderId) == null) {
				map.put(orderId, instantiateOrder(rs));
			}
			
			Product p = instantiateProduct(rs);
			map.get(orderId).getProducts().add(p);
		}
		
		for (Long id : map.keySet()) {
			System.out.println(map.get(id));
			for (Product p : map.get(id).getProducts()) {
				System.out.println(p);
			}
			System.out.println();
		}
	}
	
	private static Product instantiateProduct(ResultSet rs) throws SQLException {
		Product product = new Product();
		product.setId(rs.getLong("product_id"));
		product.setDescription(rs.getString("description"));
		product.setImageUri(rs.getString("image_uri"));
		product.setName(rs.getString("name"));
		product.setPrice(rs.getDouble("price"));
		return product;
	}
	
	private static Order instantiateOrder(ResultSet rs) throws SQLException {
		Order order = new Order();
		order.setId(rs.getLong("id"));
		order.setLatitude(rs.getDouble("latitude"));
		order.setLongitude(rs.getDouble("longitude"));
		order.setMoment(rs.getTimestamp("moment").toInstant());
		order.setStatus(OrderStatus.values()[rs.getInt("status")]);
		return order;
	}
	```

Conexão com o DB:

```java
public class DB {

	private static Connection conn = null;
	
	public static Connection getConnection() {
		if (conn == null) {
			try {
				Properties props = loadProperties();
				String url = props.getProperty("dburl");
				conn = DriverManager.getConnection(url, props);
			}
			catch (SQLException e) {
				throw new DbException(e.getMessage());
			}
		}
		return conn;
	}
	
	public static void closeConnection() {
		if (conn != null) {
			try {
				conn.close();
			} catch (SQLException e) {
				throw new DbException(e.getMessage());
			}
		}
	}
	
	private static Properties loadProperties() {
		try (FileInputStream fs = new FileInputStream("db.properties")) {
			Properties props = new Properties();
			props.load(fs);
			return props;
		}
		catch (IOException e) {
			throw new DbException(e.getMessage());
		}
	}
	
	public static void closeStatement(Statement st) {
		if (st != null) {
			try {
				st.close();
			} catch (SQLException e) {
				throw new DbException(e.getMessage());
			}
		}
	}

	public static void closeResultSet(ResultSet rs) {
		if (rs != null) {
			try {
				rs.close();
			} catch (SQLException e) {
				throw new DbException(e.getMessage());
			}
		}
	}	
}
```


### Introdução JPA  e Hibernate 

- Visão geral sobre mapeamento objeto-relacional
![[Captura de tela de 2025-04-10 08-08-16.png]]

 Outros problemas que devem ser tratados:

- Contexto de persistência (objetos que estão ou não atrelados a uma conexão em um dado momento)
- Mapa de identidade (cache de objetos já carregados)
- Carregamento tardio (lazy loading)
- Outros

JPA 
Java Persistence API é a especificação padrão da plataforma JAVA EE (pacote javax.persistence) para mapeamento objeto-relacional e persistência de dados.
JPA é apenas uma especificação (JSR 338): [http://download.oracle.com/otn-pub/jcp/persistence-2_1-fr-eval-spec/JavaPersistence.pdf](http://download.oracle.com/otn-pub/jcp/persistence-2_1-fr-eval-spec/JavaPersistence.pdf)

Para trabalhar com JPA é preciso incluir no projeto uma implementação da API (ex: Hibernate).
Arquitetura de uma aplicação que utiliza JPA:

![[Pasted image 20250410081250.png]]

- Principais classes:

EntityManager
Um objeto EntityManager encapsula uma conexão com a base de dados e serve para efetuar operações de acesso a dados (inserção, remoção, deleção, atualização) em entidades (clientes, produtos, pedidos, etc.) por ele monitoradas em um mesmo contexto de persistência.
Escopo: tipicamente mantem-se uma instância única de EntityManager para cada thread do sistema (no caso de aplicações web, para cada requisição ao sistema).

EntityManagerFactory
Um objeto EntityManagerFactory é utilizado para instanciar objetos EntityManager.
Escopo: tipicamente mantem-se uma instância única de EntityManagerFactory para toda aplicação.

